# reflection

This interactive data visualization dashboard project, which was completed in collaboration with the Gemini CLI and Cursor AI, has greatly accelerated my build process. I switched between these two tools during the build process due requests' quota limits.

At first, Cursor (an AI-Native IDE) helped me scaffolding the frontend and backend's core components by initializing new Angular and Node projects.  It was nearly instantaneous to set up the Express.js application in `server/index.js` using simple routes.  Similarly, it was easier to generate Angular components for dashboard management, file upload, user registration, and login. I was able to concentrate on the essential logic since the AI took care of the tedious chores of manually creating files, boilerplate code, and simple HTML structures.

The AI's ability to produce pertinent code snippets and recommend architectural patterns was very helpful when implementing main features like file upload, user authentication, and dashboard management. For example, the Gemini CLI supplied the required endpoint logic and configuration when integrating Multer for file uploads. Time was saved and the cognitive load of adjusting to a new data persistence layer was lessened when the AI generated the schemas, models, and updated the CRUD operations across multiple endpoints during the difficult refactoring task of switching from file-based storage to Mongoose for MongoDB integration.  With the AI supplying the required middleware and endpoint logic, the configuration of JWT-based authentication with `bcrypt` for password hashing was also completed effectively.

But there were difficulties in the process. The way the CLI interacted with directory-specific commands and `npm install` was a persistent problem.  The tool frequently reported that the directory was not a registered workspace or that `npm install` was not successfully executed, even though the `directory` parameter was specified.  Packages like `express`, `multer`, `bcrypt`, `jsonwebtoken`, `mongoose`, `tailwindcss`, `postcss`, `autoprefixer`, and `cors` had to be installed manually as a result. I had to exit the AI-driven process to run commands directly in the terminal because of these interruptions, which disrupted the flow. Similar opposition was encountered when establishing directories and initializing Tailwind CSS with `npx tailwindcss init`, necessitating the creation and configuration of files by hand.

The use of Tailwind CSS styles was another point of contention. The initial attempt to apply styles didn't go as planned, even though the AI correctly identified the steps (installing dependencies, configuring `tailwind.config.js`, adding directives to `styles.scss`, and creating `postcss.config.js`). The need for strong self-verification or more clear instructions from the AI when such problems occur is highlighted by the fact that this necessitated an extra diagnostic step to make sure `postcss.config.js` was configured correctly and that the Angular development server was restarted.

Notwithstanding these difficulties, Gemini CLI and Cursor AI had an overwhelmingly positive effect on productivity overall.  It was impressive how quickly boilerplate code was generated, how accurately features were implemented based on the `README.md` context, and how quickly large portions of the backend could be refactored. These AI tools guided the development process and offered quick fixes, acting as an experienced pair programmer. The amount of time spent searching for syntax, best practices, or typical integration patterns was greatly decreased.

In conclusion, the Gemini CLI and Cursor AI was an excellent build process accelerator, particularly in feature implementation and code generation. While there is potential for improvement in tool resilience as well as error handling, the fact that it is context-aware, generates complex code, and can drive development means that it is a must-have for software developers. The exercise showed the potential for AI to transform how we create apps, allowing developers to focus more on designing and less on tedious coding.
